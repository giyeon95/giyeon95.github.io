---
title: "[Clean Architecture] 5부 아키텍처"
date: 2023-02-17 15:21:10 +0900
categories: book
---

# 15장 아키텍처란?

**아키텍처의 목적**

- 시스템의 생명주기를 지원하는 것
  - 즉 쉽게 개발하며, 쉽게 유지보수하고 또 쉽게 배포하게 만들어준다.
- 시스템의 수명과 관련 비용은 최소화 및 프로그래머의 생산성은 최대화 하는것

- 개발하기 힘든 시스템이라면 수명이 길지도 않고 건강하지도 않을 것이다.
  - 따라서 아키텍처는 개발팀이 시스템을 쉽게 개발할 수 있도록 뒷받침해야만 한다.
- 배포의 비용이 높을수록 시스템의 유용성은 떨어진다.
  - 쉽게 배포할 수 있도록 아키텍처를 구성해야한다.
  - 단 만약 개발 초기에 MSA 환경으로 개발한다면?
    - 컴포넌트 경계가 매우 뚜렷해지고 인터페이스가 대체로 안정화되므로 시스템을 쉽게 개발할 수 있을 수는 있지만, **배포할 시기가 되면 위협적일 만큼 늘어난 마이크로서비스가 부담이 될 수도 있다.**
- 유지보수에서 가장 큰 비용은 탐사이다. (탐사: 신규 기능 추가 및 결함을 수정할때 영향도를 파악 및 검토하는데 드는 비용)
  - 즉 이러한 부분에 주의를 기울여 신중하게 아키텍처를 만들면 이 비용을 크게 줄일 수 있다.
- 시스템에서 정책을 가장 핵심적인 요소로 식별하고, 동시에 세부사항은 정책에 무관하게 만들 수 있는 형태를 만드는 것
  - 소프트웨어의 구조적 가치는 부드럽게 만들어야 한다.
  - 부드럽게 유지하는 방법은 **중요치 않은 세부사항**을 가능한 한 많이, 그리고 가능한 한 오랫동안 열어 두어야 한다.

#  16장 독립성

좋은 아키텍처는 다음을 지원해야 한다.

- 시스템의 유스케이스
- 시스템의 운영
- 시스템의 개발
- 시스템의 배포



## 유스케이스

- 시스템의 **의도**를 지원해야한다.
- 좋은 아키텍처는 **행위를 명확히 하고 외부로 드러내**며, 시스템이 지닌 의도를 **아키텍처 수준에서 알아볼 수 있게 만드는 것**이다.
  - 장바구니 애플리케이션이 좋은 아키텍처를 가진다면, 이 애플리케이션은 장바구니 애플리케이션처럼 보여야 하며, 시스템의 유스케이스는 시스템 구조에서 한눈에 드러날 것이다.

## 운영

- 시스템이 초당 100,000명의 고객을 처리해야한다면 아키텍처는 이 요구와 관련된 각 유스케이스에 걸맞은 처리량과 응답시간을 보장해야한다.
- 이러한 형태의 요구사항은 시스템의 크기에 따라 다양하게 구현할 수 있으며 이러한 결정은 뛰어난 아키텍트라면 **열어두어야 하는 선택사항중 하나**이다.



## 개발

- 많은 팀으로 구성된 다양한 조직에서 어떤 시스템을 개발해야 한다면, 팀들은 서로를 방해하지 않도록 해야한다.
  - 잘 격리되어 있고 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할할 수 있어야 한다.

## 배포

- 좋은 아키텍처라면 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야한다.
  - 배포시 수작업은 가능한 없어야 하며, **즉각적인 배포**라는 목표를 지향한다.



**다만 현실의 요구사항은 시시각각 변한다. 좋은 아키텍처는 선택사항을 열어둠으로써, 향후 시스템에 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록 한다.**

- 다른 속도로, 그리고 다른 이유로 변경되는 규칙은 서로 분리하고 독립적으로 변경할 수 있도록 만들어야만 한다.
- 유스케이스는 시스템을 분할하는 매우 자연스러운 방식이다. 서로 다른 관점(aspect)를 분리하자.
- 컴포넌트를 다른 서버에 실행해야 한다면 **독립된 서비스가** 되어야 하고, 일종의 네트워크를 통해 서로 통신한다. 많은 아키텍트가 이러한 컴포넌트를 서비스 또는 마이크로서비스라고 하며, 이런 서비스에 기반한 아키텍처를 **서비스 지향 아키텍처(service oriented architecture)**라고 부른다.
- 중복된 코드는 제거하는 것이 좋지만, 거짓된 또는 우발적인 중복인 경우는 주의하라.
  - 두 코드가 시간이 지날수록 각자의 경로로 발전한다면 이코드는 중복이 아니다.

# 17장 경계: 선 긋기

- 경계란 소프트웨어 요소를 서로 분리하고, 서로 다른 경계의 요소를 알지 못하도록 선을 긋는 것이다.
- 결합(Coupling)은 인적자원의 효율을 떨어뜨리는 요인인데, 너무 일찍 내려진 결정에 따른 결합을 주의하라
- 관련이 있는 것과 없는 것 사이에 선을 그어라
  - GUI는 업무규칙과 관련이 없다.
  - 데이터베이스는 GUI와 관련이 없다.
  - 데이터베이스와 업무 구칙은 관련이 없다. (DB를 Mysql, Oracle 등 어떤 것을 사용할 수도 있다.)
- **경계는 변경의 축(axis of change)이 있는 지점에 그어진다.** 경계의 한쪽에 위치한 컴포넌트는 경계 변대편의 컴포넌트와는 다른 속도로 그리고 다른 이유로 변경된다.



# 18장 경계 해부학

- 소스코드 의존성 관리를 통해 적절한 위치에서 경계를 횡단하도록 구성할 수 있다.
- 가장 단순한 경계의 횡단은 저수준 클라이언트에서 고수준 서비스로 향하는 함수 호출이다.
  - 고수준 클라이언트가 저수준 서비스를 호출해야 한다면, **동적 다형성을 사용하여 의존성을 역전(DI) 시킬 수** 있다.
- 스레드는 아키텍처 경계도 아니고 배포 단위도 아니다. 단지 실행 계획과 순서를 체계화 하는 방법에 가깝다
- 로컬 프로세스를 통해 경계를 나눌 수도 있다. 로컬 프로세스는 컴포넌트간 의존성을 동적 다형성을 관리하는 저수준 컴포넌트로 구성된다. 즉 항상 고수준 컴포넌트를 향해야 한다. 다만, 로컬프로세스 경계를 지나는 통신에는 운영체제 호울, 데이터 마샬링 및 언 마샬링 컨텍스트 스위칭 등이 있으며 이는 비용이 비싸므로 통신이 빈번하게 이뤄져서는 안된다.
- 서비스는 네트워크를 통해 통신이 이뤄지며, 물리적 위치에 구애받지 않으며 가장 강력한 경계 서비스 이다.
  - 고수준 서비스의 소스코드에는 저수준 서비스를 특정짓는 어떤 물리적인 정보를 절대 포함해서는 안된다.

# 19장 정책과 수준

# 20장 업무 규칙

# 21장 소리치는 아키텍처



# 22장 클린 아키텍처



# 23장 프레젠터와 험블 객체



# 24장 부분적 경계



# 25장 계층와 경계



# 26장 메인(Main) 컴포넌트



# 27장 '크고 작은 모든' 서비스들

# 28장 테스트 경계

# 29장 클린 임베디드 아키텍처
