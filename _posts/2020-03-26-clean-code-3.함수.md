---
title: "Clean Code 기록하기 Day-2"
date: 2020-03-26 22:10:10 -0400
categories: book
---


함수란 단위는 어떤 프로그램이든 가장 기본적인 단위다.
이 장에서는 함수를 잘 만드는 방법을 소개한다고 한다.


## 작게 만들어라
> 함수를 만드는 첫째 규칙은 **작게**, 가능하면 **더 작게**이다.
> if / else / while 과같은 문에 들어가는 블록 한줄로 함수를 호출하고 함수 이름을 적절히 짓는다면, 코드를 이해하기도 쉬워진다.

## 한가지만 해라!
> 함수의 역할은 한가지만 한다. 
> 그 한가지를 잘해야 한다. 
> 그 한가지 만을 해야한다. 
> **추상화 수준이 하나인 단계만 수행하도록 하자.**

## 함수당 추상화 수준은 하나로!
> 한 함수 내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다.
> 근본개념과 세부사항을 뒤섞기 시작하면 함수에 세부사항을 추가할때 점점 더 섞이기 시작한다.

##### 위에서 아래로 코드 읽기: **내려가기** 규칙
- 코드는 위에서 아래로 이야기 처럼 읽히면 좋다. 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 오는 것이다.

##### *추상화 수준이 하나인 함수를 구현하는 것은 쉽지 않지만 매우 중요하다.*


## Switch 문
> switch문은 작게 만들기 어렵고, 한가지 작업만 하는 switch문을 만들기도 어렵다.
> 하지만 각 switch문을 저차원 클래스에 숨기고 절대로 반복하지 않는 방법은 있다. *(다형성을 이용)*

```
public Money calculatePay(Employee e) 
    throws InvalidEmployeeType {
        switch (e.type) {
            case COMMISSIONED:
                return caculateCommissionedPay(e);
            case HOURLY:
                return calculateHourlyPay(e);
            case SALARIED:
                return calculateSalariedPay(e);
            default:
                throw new InvalidEmployeeType(e.type);
        }
}
```

#### 위 함수의 문제점
1. 함수가 길다.
2. '한 가지' 작업만 수행하지 않는다.
3. SRP(단일 책임 원칙)을 위반한다.
4. OCP(개방 폐쇄의 원칙)을 위반한다. - 새 직원 유형을 추가할 때 마다 코드를 변경해야 한다.
5. 위 함수와 구조가 동일한 함수가 무한정 존재할 수 있다. 


###### 구조가 동일한 함수 예시: isPayDay(Employee e, Date date) or deliverPay(Employee e, Money pay)
###### **SRP(Single Responsibility Principle)** : SOLID 5대 원칙중 S에 해당하며, 모든 클래스는 하나의 책임을 가지며 그 책임을 수행 하는데 집중되어 있어야한다 .
###### **OCP(Open Closed Principle)** : SOLID 5대 원칙중 O에 해당하며, 확장에는 열려있으며, 변경에는 닫혀 있어야한다. 


#### 위 문제의 해결 방법 : **추상 팩토리 패턴(Abstract Factory Pattern)**

```
public abstract class Employee {
    public abstract boolean isPayday();
    public abstract Money calculatePay();
    public abstract void deliverPay(Money pay);
}

--------------------

public interface EmployeeFactory {
    public Employee makeEmployee(EmployeeRecord r) 
        throws InvalidEmployeeType;
}

--------------------

public class EmployeeFactoryImpl implements EmployeeFactory {
    public Employee makeEmployee(EmployeeRecord r)
        throws InvalidEmployeeType {
            switch (r.type) {
                case COMMISSIONED:
                    return new CommissionedEmployee(r);
                case HOURLY:
                    return new HourlyEmployee(r);
                case SALARIED:
                    return new SalariedEmployee(r);
                default:
                    throw new InvalidEmployeeType(r.type);
            }
}

```
1. Switch문은 추상 팩토리(EmployeeFactoryImpl)에 꽁꽁 숨긴다.
2. Factory는 적절한 Employee의 파생클래스(CommissionedEmployee, HourlyEmployee, SalariedEmployee) 와 같은 인스턴스를 생성한다.
3. calculatePay, isPayday, deliverPay와 같은 함수는 Employee 인터페이스를 거쳐 호출한다.
4. 그러면 다형성으로 인해 실제 파생클래스의 함수가 실행된다.

---

-- 추가 작성 예정 --
