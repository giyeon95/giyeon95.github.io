---
title: "[Clean Architecture] 5부 아키텍처"
date: 2023-02-17 15:21:10 +0900
categories: book
---

# 15장 아키텍처란?

**아키텍처의 목적**

- 시스템의 생명주기를 지원하는 것
  - 즉 쉽게 개발하며, 쉽게 유지보수하고 또 쉽게 배포하게 만들어준다.
- 시스템의 수명과 관련 비용은 최소화 및 프로그래머의 생산성은 최대화 하는것

- 개발하기 힘든 시스템이라면 수명이 길지도 않고 건강하지도 않을 것이다.
  - 따라서 아키텍처는 개발팀이 시스템을 쉽게 개발할 수 있도록 뒷받침해야만 한다.
- 배포의 비용이 높을수록 시스템의 유용성은 떨어진다.
  - 쉽게 배포할 수 있도록 아키텍처를 구성해야한다.
  - 단 만약 개발 초기에 MSA 환경으로 개발한다면?
    - 컴포넌트 경계가 매우 뚜렷해지고 인터페이스가 대체로 안정화되므로 시스템을 쉽게 개발할 수 있을 수는 있지만, **배포할 시기가 되면 위협적일 만큼 늘어난 마이크로서비스가 부담이 될 수도 있다.**
- 유지보수에서 가장 큰 비용은 탐사이다. (탐사: 신규 기능 추가 및 결함을 수정할때 영향도를 파악 및 검토하는데 드는 비용)
  - 즉 이러한 부분에 주의를 기울여 신중하게 아키텍처를 만들면 이 비용을 크게 줄일 수 있다.
- 시스템에서 정책을 가장 핵심적인 요소로 식별하고, 동시에 세부사항은 정책에 무관하게 만들 수 있는 형태를 만드는 것
  - 소프트웨어의 구조적 가치는 부드럽게 만들어야 한다.
  - 부드럽게 유지하는 방법은 **중요치 않은 세부사항**을 가능한 한 많이, 그리고 가능한 한 오랫동안 열어 두어야 한다.

#  16장 독립성

좋은 아키텍처는 다음을 지원해야 한다.

- 시스템의 유스케이스
- 시스템의 운영
- 시스템의 개발
- 시스템의 배포



## 유스케이스

- 시스템의 **의도**를 지원해야한다.
- 좋은 아키텍처는 **행위를 명확히 하고 외부로 드러내**며, 시스템이 지닌 의도를 **아키텍처 수준에서 알아볼 수 있게 만드는 것**이다.
  - 장바구니 애플리케이션이 좋은 아키텍처를 가진다면, 이 애플리케이션은 장바구니 애플리케이션처럼 보여야 하며, 시스템의 유스케이스는 시스템 구조에서 한눈에 드러날 것이다.

## 운영

- 시스템이 초당 100,000명의 고객을 처리해야한다면 아키텍처는 이 요구와 관련된 각 유스케이스에 걸맞은 처리량과 응답시간을 보장해야한다.
- 이러한 형태의 요구사항은 시스템의 크기에 따라 다양하게 구현할 수 있으며 이러한 결정은 뛰어난 아키텍트라면 **열어두어야 하는 선택사항중 하나**이다.



## 개발

- 많은 팀으로 구성된 다양한 조직에서 어떤 시스템을 개발해야 한다면, 팀들은 서로를 방해하지 않도록 해야한다.
  - 잘 격리되어 있고 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할할 수 있어야 한다.

## 배포

- 좋은 아키텍처라면 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야한다.
  - 배포시 수작업은 가능한 없어야 하며, **즉각적인 배포**라는 목표를 지향한다.



**다만 현실의 요구사항은 시시각각 변한다. 좋은 아키텍처는 선택사항을 열어둠으로써, 향후 시스템에 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록 한다.**

- 다른 속도로, 그리고 다른 이유로 변경되는 규칙은 서로 분리하고 독립적으로 변경할 수 있도록 만들어야만 한다.
- 유스케이스는 시스템을 분할하는 매우 자연스러운 방식이다. 서로 다른 관점(aspect)를 분리하자.
- 컴포넌트를 다른 서버에 실행해야 한다면 **독립된 서비스가** 되어야 하고, 일종의 네트워크를 통해 서로 통신한다. 많은 아키텍트가 이러한 컴포넌트를 서비스 또는 마이크로서비스라고 하며, 이런 서비스에 기반한 아키텍처를 **서비스 지향 아키텍처(service oriented architecture)**라고 부른다.
- 중복된 코드는 제거하는 것이 좋지만, 거짓된 또는 우발적인 중복인 경우는 주의하라.
  - 두 코드가 시간이 지날수록 각자의 경로로 발전한다면 이코드는 중복이 아니다.

# 17장 경계: 선 긋기

- 경계란 소프트웨어 요소를 서로 분리하고, 서로 다른 경계의 요소를 알지 못하도록 선을 긋는 것이다.
- 결합(Coupling)은 인적자원의 효율을 떨어뜨리는 요인인데, 너무 일찍 내려진 결정에 따른 결합을 주의하라
- 관련이 있는 것과 없는 것 사이에 선을 그어라
  - GUI는 업무규칙과 관련이 없다.
  - 데이터베이스는 GUI와 관련이 없다.
  - 데이터베이스와 업무 구칙은 관련이 없다. (DB를 Mysql, Oracle 등 어떤 것을 사용할 수도 있다.)
- **경계는 변경의 축(axis of change)이 있는 지점에 그어진다.** 경계의 한쪽에 위치한 컴포넌트는 경계 변대편의 컴포넌트와는 다른 속도로 그리고 다른 이유로 변경된다.



# 18장 경계 해부학

- 소스코드 의존성 관리를 통해 적절한 위치에서 경계를 횡단하도록 구성할 수 있다.
- 가장 단순한 경계의 횡단은 저수준 클라이언트에서 고수준 서비스로 향하는 함수 호출이다.
  - 고수준 클라이언트가 저수준 서비스를 호출해야 한다면, **동적 다형성을 사용하여 의존성을 역전(DI) 시킬 수** 있다.
- 스레드는 아키텍처 경계도 아니고 배포 단위도 아니다. 단지 실행 계획과 순서를 체계화 하는 방법에 가깝다
- 로컬 프로세스를 통해 경계를 나눌 수도 있다. 로컬 프로세스는 컴포넌트간 의존성을 동적 다형성을 관리하는 저수준 컴포넌트로 구성된다. 즉 항상 고수준 컴포넌트를 향해야 한다. 다만, 로컬프로세스 경계를 지나는 통신에는 운영체제 호울, 데이터 마샬링 및 언 마샬링 컨텍스트 스위칭 등이 있으며 이는 비용이 비싸므로 통신이 빈번하게 이뤄져서는 안된다.
- 서비스는 네트워크를 통해 통신이 이뤄지며, 물리적 위치에 구애받지 않으며 가장 강력한 경계 서비스 이다.
  - 고수준 서비스의 소스코드에는 저수준 서비스를 특정짓는 어떤 물리적인 정보를 절대 포함해서는 안된다.

# 19장 정책과 수준

- 동일한 시점에 변경되는 정책은 동일한 수준에 위치하며, 동일한 컴포넌트에 위치해야한다.
- 저수준 컴포넌트가 고수준 컴포넌트에 의존하도록 설계되어야 한다.
- 수준은 `입력과 출력까지의 거리` 라고도 표현할 수 있다.
- 정책을 컴포넌트로 묶는 기준은 단일 책임원칙과 공통 폐쇄원칙에 따르면 동일 시점에 변경되는 정책은 함께 묶인다.
  - 고수준 정책은 저수준 정책에 비해 덜 빈번하게 변경되고 보다 중요한 이유로 변경되는 경향이 있다

# 20장 업무 규칙

## 엔티티

- 엔티티란 컴퓨터 내부의 객체로서, 핵심 업무 데이터를 기반으로 동작하는 일련의 조그만 핵심 업무 규칙을 구체화한다.
- 엔티티는 순전히 업무에 대한 것이며, 데이터베이스, 사용자 인터페이스, 서드파티 프레임워크로 오염되어서는 안된다.

## 유스케이스

- 유스케이스는 사용자가 제공해야하는 입력, 사용자에게 보여줄 출력, 그리고 해당 출력을 생성하기 위한 처리 단계를 기술한다. 즉 애플레케이션에 특화된(application-specific) 업무 규칙을 설명한다.
- 유스케이스는 시스템이 사용자에게 어떻게 보이는지를 설명하지 않는다. 이보다는 애플리케이션에 특화된 규칙을 설명하며, 이를 통해 사용자와 엔티티 사이의 상호작용을 규정한다.
  - 웹을 통해 전달되는지, 콘솔기반인지 등 사용자에게 어떻게 조회되는지는 유스케이스에서는 알 필요가 없다.



엔티티는 자신을 제어하는 유스케이스에 대해서 알지 못한다. 즉 엔티티는 유스케이스에 비해 고수준 개념이며 그에대한 이유는 유스케이스는 단일 애플리케이션에 특화되어 있으며, 입력과 출력에 엔티티보다 가깝게 존재한다.

> 유스케이스는 엔티티에 의존한다. 그러나 엔티티는 유스케이스에 의존하지 않는다.

# 21장 소리치는 아키텍처

- 소프트웨어 아키텍처는 어떤 애플리케이션인지 한눈에 알 수 있도록 설계되어야 한다.

  - 프레임 워크에 대한 것이 되어서는안된다. (Spring, Hibernate, Reils 등..)

- 좋은 소프트웨어 아키텍처는 여러 개발환경이나 도구에 대해 결정을 미룰 수 있도록 만든다.

- 테스트하기 좋은 아키텍처는 웹서버, 데이터베이스, 프레임워크 등이 없어도 테스트를 돌릴 수 있어야 한다.

  

# 22장 클린 아키텍처

- 지난 수십년간 나온 아키텍처들의 목표는 `관심사의 `분리 이다.
  - 소프트웨어를 계층으로 분리함으로써 최소한의 업무규칙을 위한 계층과 시스템 인터페이스를 위한 또다른 계층 하나를 반드시 포함하며, `프레임워크 독립성`, `테스트 용이성`, `UI 독립성`, `Database 독립성`, `외부 에이전시에 대한 독립성`이라는 장점을 가질 수 있다.



<img width="673" alt="CleanShot 2023-03-18 at 16 35 32@2x" src="https://user-images.githubusercontent.com/37217320/226092070-63ce7af9-9d07-478d-b199-7f1d66c59256.png">

<이미지 출처: http://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html>

- 소스코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다.
- 엔티티는 가장 일반적이며 고수준인 규칙을 캡슐화 한다.
- 유스케이스는 엔티티가 자신의 핵심 엄부 규칙을 사용해서 유스케이스의 목적을 달성하도록 이끈다.
- 인터페이스 어뎁터는 데이터를 유스케이스와 엔티티에게 가장 편리한 형식에서 데이터베이스나 웹같은 외부 에이전시에게 가장 편리한 형식으로 변환한다.
- 프레임워크와 드라이버 계층은 세부사항이며, 외부에 위치시켜 변경에 대한 피해를 최소화 한다.
- 경계를 횡단할때는 데이터 전송 객체(data transfer object) 등 을 사용한다. 중요한 것은 안쪽에 있는 객체(Entity)나 데이터 베이스의 행(row)가 전달되면 의존성 규칙을 위배하게 된다.

# 23장 프레젠터와 험블 객체

- 험블 객체 패턴이란 테스트하기 어려운 행위와 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법이며, 테스트하기 어려운 행위를 모두 험블 객체로 옮긴다.
- 행위를 테스트하기 쉬운 부분과 어려운 부분으로 분리하면 아키텍처 경계가 정의될 수 있다.
- 각 레이어별로, 테스트 용이성은 다음과 같다.
  - 뷰는 테스트 하기 어려우며 험블객체이다.
  - 프레젠터는 테스트 하기 쉽다.
  - 인터렉터는 애플리케이션에 특화된 업무 규칙을 캡슐화하기에 험블 객체가 아니며, 테스트하기 쉽다. 또한 내부적으로 사용하는 데이터베이스 게이트웨이에는 스텁이나 테스트더블로 교체할 수 있다.
- 험블 객체 패턴을 사용하면 전체 시스템의 테스트 용이성을 크게 높일 수 있다.

# 24장 부분적 경계

- 모든 아키텍처의 경계를 완벽하게 만드는데는 비용이 많이 든다. 그러나 한편으로는 나중에 필요해보일 수 있는 부분도 있는데 이런 상황에 **부분적 경계**를 구현해 볼 수 있다.
- 독립적으로 컴파일하고 배포할 수 있는 컴포넌트를 만들기 위한 작업을 모두 수행하고, 단일 컴포넌트에 모아만 두는 방법도 있다.
- 전략 패턴을 통해 확장 가능성을 열어 둘 수도 있다.
- 더 간단한 경계는 퍼사드 패턴을 이용할 수도 있다. (메소드를 호출할때 클래스로 전달하도록) 그러나 Client는 추이 종속성을 가지게 된다.

# 25장 계층와 경계

- 이 장에서는 계층과 경계를 나눈 사례를 움파스 게임이라는 예제를 통해 보여준다.
- 계층과 경계를 제대로 구현하려면 비용이 많이 든다는 사실도 인지하라.
- 다만 계층과 경계가 무시되었다면 나중에 다시 추가하는 비용도 크다.



# 26장 메인(Main) 컴포넌트

- 메인 컴포넌트는 궁극적인 세부사항으로 가장 낮은 수준의 정책을 의미한다.
- 메인은 클린 아키텍처에서 가장 바깥 원에 위치하는 낮은 수준의 모듈이다.
- 메인은 애플리케이션의 플러그인이라고 생각하자고 경계 바깥에 위치한다고 보면 설정 관련 문제를 훨씬 쉽게 해결할 수 있다.

# 27장 '크고 작은 모든' 서비스들

- 서비스를 사용하더라도 상호 결합이 무조건 철저하게 분리되지는 않는다.
  - 서비스를 분리함으로써 얻게 되는 큰 이점은 각 서비스 사이의 결합이 확실하게 분리되며, 이는 별도의 프로세스로 실행된다.
  - 단 **프로세스 사이 자원을 공유해야 한다면 공유하는 데이터에 의해 서비스는 강력하게 결합된다**.
- 서비스를 사용하더라도 개발과 배포 독립성이 모두 지원되지는 않는다.
  - 서비스를 사용함에 따라 얻는 이점으로 전담팀이 서비스를 소유하고 운영할 수 있다. 즉 배포 독립성을 가져가며 확장 가능한 것으로 간주된다.
  - 그러나, 데이터나 행위에서 다른 서비스와 결합되어 있다면 개발, 배포, 운영을 조정해야만 한다.
- 아키텍처의 경계가 반드시 서비스 사이에 있지는 않는다.
  - 오히려 컴포넌트 단위로 분할하며, 내부 의존성 규칙도를 준수하는 컴포넌트 아키텍처로 설계해야한다.

# 28장 테스트 경계

- 모든 테스트는 독립적으로 배포가 가능해야하며, 가장 바깥쪽에 원에 위치한다. 즉, 시스템 운영 코드는 테스트 코드에 의존해서는 안된다.
- 깨지기 쉬운 테스트는 시스템을 뻣뻣하게 만들며, 이를 고려해서 테스트를 설계하라.
  - GUI와 같이 변동성이 큰 것에 의존하지 말아라.
  - 테스트에 특화된 API를 이용함으로서, DB와 같이 값비싼 자원은 건너뛰고 시스템을 테스트 가능한 상태로 만들 수 있어야 한다.
  - 테스트 API의 역할은 애플리케이션의 구조를 테스트로부터 숨기는데 있으며, 이렇게 만들면 테스트를 리팩터링 하거나 진화시킬 때도 상용 코드에는 전혀 영향을 주지 않는다.
- 테스트는 시스템 외부에 있지는 않다. 테스트를 시스템 외부로 설계한다면 이후 변경에 깨지기 쉽고 유지보수가 어려워져 테스트코드는 점차 버려지게 된다.

# 29장 클린 임베디드 아키텍처

- 해당 장은 임베디드 개발자들이 어떤 식으로 클린 아키텍쳐를 적용해야 할지에 대한 사례를 이야기 한다.
- 소프트웨어는 닳지 않지만, 펌웨어와 하드웨어에 대한 의존성을 관리하지 않으면 안으로부터 파괴될 수 있다.
  - 소프트웨어를 개발할때, 하드웨어에 대한 세부사항을 알지 못하도록 하여라
  - 프로세서와 운영체제는 세부사항이다. 즉 인터페이스를 통하고 대체 가능성을 높이는 방향으로 프로그래밍 하라.
