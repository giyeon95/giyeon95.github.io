---
title: "[Clean Architecture] 3부 설계 원칙"
date: 2023-01-21 22:19:10 +0900
categories: book
---

SOLID는 좋은 아키텍처를 정의하는 원칙이며 아래와 같도록 만드는 데 목적이 있다.

- 변경에 유연하다
- 이해하기 쉽다
- 많은 소프트웨어 시스템에 사용할 수 있는 컴포넌트의 기반이 된다.

# 7장 SRP: 단일 책임 원칙

**각 소프트웨어 모듈은 변경의 이유가 하나여야만 하며 오직 하나의 액터에 대해서만 책임져야 한다.** 사실 이름만 보면 커다란 함수는 반드시 하나의 일을 해야한다로 이해할 수도 있지만, 이는 다른 원칙이며 이는 커다란 함수들로 리펙터링하는 더 저수준에서 사용된다.



## 원칙을 위반하는 징후들

### 우발적 중복

이 책에서는 Employee 클래스로 사례를 들고 있다.

<img width="447" alt="CleanShot 2023-03-18 at 17 43 25@2x" src="https://user-images.githubusercontent.com/37217320/226095175-9e7cfed8-9eba-4be4-8391-3c0cc1c03173.png">

- calculatePay(): 회계팀에서 사용하는 기능
- reportHours(): 인사팀에서 사용하는 기능
- save(): DBA가 사용하는 기능

서로 다른 사용자가 사용하는 기능이 내부적으로 사용하는 알고리즘이 공유된다고 가정하고, 특정 직원이 사용하는 알고리즘만 변경되어야 한다고 하여 수정한다면, 내부적으로 다른 직원이 사용하는 메소드도 영향이 갈 수 있다.

### 병합

서로다른 개발자가 다른 기능 수정을 위해 동시에 같은 클래스를 수정한다면, 변경사항이 충돌된다.

> DBA가 사용하는 기능인 save를 수정하며, 회계팀에서 calculatePay()도 수정하는 경우를 가정한다



## 해결책

각 메서드를 각기 다른 클래스로 이동시켜라. 이렇게 하면 세 클래스는 서로의 존재를 모른다.

<img width="449" alt="CleanShot 2023-03-18 at 17 43 47@2x" src="https://user-images.githubusercontent.com/37217320/226095191-bc9a6b3a-1815-4563-9226-64729b1629b8.png">

다만 이 해결책은 개발자가 세 가지 클래스를 인스턴스화 하고 추적해야 한다는 게 단점이다. 이런 단점을 개선하기 위해 사용되는 기법으로 `퍼사드(Facade) 패턴`이 있다.

<img width="447" alt="CleanShot 2023-03-18 at 17 44 06@2x" src="https://user-images.githubusercontent.com/37217320/226095202-5b1d0b1a-89cc-4706-9345-b53024f1566a.png">



```java
public class EmployeeFacade {
  
  private final PayCalculator payCalculator;
  private final HourReporter hourReporter;
  private final EmployeeSaver employeeSaver;
  
  public EmployeeFacade(PayCalculator payCalculator, HourReporter hourReporter, EmployeeSaver employeeSaver) {
    	this.payCalculator = payCalculator;
    	this.hourReporter = hourReporter;
    	this.employeeSaver = employeeSaver;
  }
  
  public void calcluatePay() {
    	payCalculator.calculatorPay();
  }
  
  public void hourReporter() {
    hourReporter.reportHours();
  }
  
  public void save() {
    employeeSaver.save();
  }
}
```

> 개인적인 생각으로 위임패턴이라고도 생각할 수 있을 것같은데, 이 디자인의 목적이 퍼사드패턴에 더 가까워 보이기도 한다.



혹은 가장 중요한 업무규칙만 Employee 클래스에 유지하며, 덜 중요한 클래스를 퍼사드로도 사용해볼 수도 있다.

<img width="429" alt="CleanShot 2023-03-18 at 17 44 23@2x" src="https://user-images.githubusercontent.com/37217320/226095211-95bc9157-1845-4233-b72d-28ab30acc944.png">

위의 방법은 모든 클래스는 반드시 단 하나의 메서드를 가져야 한다는 주장에 근거하여 반대될 수도 있지만, 현실적으로 수많은 private 메서드를 포함할 수도 있다.



## 결론

단일 책임의 원칙은 메서드와 클래스 수준의 원칙이다. 컴포넌트 수준에서는 공통 폐쇄 원칙 (Common Closure Principle)이 되며, 아키텍처 경계(Architecture Boundary)의 생성을 책임지는 변경의 축(Axis of Changes)가 될 수도 있다. 이러한 개념들은 이후의 장에서 나온다고 한다.

# 8장 OCP: 개방-폐쇄 원칙

기존 코드를 수정하기보다는 반드시 새로운 코드를 추가하는 방식의 행위를 변경할 수 있도록 설계해야 한다. **즉 소프트웨어 개체는 확장에는 열려있어야 하고, 변경에는 닫혀 있어야 한다.**

## 사고 실험

소프트웨어 아키텍처가 훌륭하다면 변경되는 코드의 양은 최소화 되어야 하며, 이상적인 변경량은 0이다.

이 책에서의 설명하는 사례는 아래와 같다.

- 재무제표를 웹 페이지로 보여주는 시스템이 있으며, 웹 페이지에 표시되는 데이터는 스크롤할 수 있으며, 음수는 빨간색으로 출력한다.
- 이해관계자가 동일한 정보를 흑백 프린트로 출력할 수 있는 기능을 추가로 요청했다고 가정

단일 책임의 원칙을 적용하면 아래와 같이 구성될 수 있다.

<img width="449" alt="CleanShot 2023-03-18 at 17 44 39@2x" src="https://user-images.githubusercontent.com/37217320/226095227-9c41c56b-5ea4-4be7-92a1-81f9e7c05dba.png">

이를 컴포넌트 관계로 표현해보면 아래와 같이 구성된다.

- View, Presenter, Controller, Interactor, Database 계층으로 구분이 가능하다.

> 책에는 더 상세한 단위로도 표기되어 있다.

<img width="450" alt="CleanShot 2023-03-18 at 17 44 53@2x" src="https://user-images.githubusercontent.com/37217320/226095245-1f13c28e-b524-447e-a025-fe884c53e6e1.png">

A컴포넌트에서 발생한 변경으로부터 B 컴포넌트를 보호하려면 A컴포넌트는 B 컴포넌트에 의존해야한다.

즉 Presenter에서 발생한 변경은 Controller를 보호하고자 하며, View에서 발생한 변경은 Presenter을 보호하게 된다. (영향이 있으면 안된다.)

여기서 특이한점은 Interactor은 어떤 변경도 영향을 줄 수 없도록 설계되었는데 Interactor은 업무 규칙(가장 높은 수준의 정책)을 포함하고 있기에, 보호해야한다.



이런 내용이 아키텍처 수준에서 OCP가 동작하는 방식이며, 아키텍트는 계층화하고 분리한 기능을 컴포넌트의 단위로 조직화 한다.



> 이 장에서는 방향성 제어와 정보 은닉에 대한 내용이 추가로 나오는데, DIP의 개념이 들어간 것 같아, 뒷장에서 정리하고자 한다.

## 결론

OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데 있다. 이런 목표를 달성하고자 한다면 **시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층 구조가 만들어져야한다.**

# 9장 LSP: 리스코프 치환 원칙

하위타입의 구성요소와 상위타입의 구성요소는 반드시 서로 치환이 가능해야한다.

<img width="418" alt="CleanShot 2023-03-18 at 17 45 07@2x" src="https://user-images.githubusercontent.com/37217320/226095272-ca9b31f3-aeb2-492f-bbb1-a4e1a7b6a625.png">

위 설계는 Billing 어플리케이션의 행위가 License 하위 타입중 무엇을 사용하는지에 전혀 의존하고 있지 않기에, 하위 타입은 모두 License로 치환할 수 있다.

아키텍처 관점에서 LSP를 이해하는 최선의 방법은 원칙을 어겼을때 무슨일이 발생하는지를 관찰 하는 것이다.

> 책에서는 위반사례를 설명하며, 예외 로직이 발생하면 if 문으로 분기를 해야한다고 이야기 한다. 만약 이런 로직이 계속 반복된다면, 기능확장시 OCP를 위반하게 되며, SRP도 위반될 수 있을 것 같다.



## 결론

LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 한다. 치환 가능성이 위배된다면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수 있기 때문이다.

# 10장 ISP: 인터페이스 분리 원칙

사용하지 않은 것에 의존하지 않아야 한다.

<img width="432" alt="CleanShot 2023-03-18 at 17 45 21@2x" src="https://user-images.githubusercontent.com/37217320/226095284-a291bf75-c171-486e-8e33-ea47f756d728.png">

User1 은 op1만, User2는 op2만, User3은 op3만 사용한다고 가정해보자. 만일 op1이 수정된다면, User2와 User3은 op1을 전혀 사용하지 않음에도 op1이 변경되면 User2와 3도 재 컴파일 후 새로 배포한다.

이를 아래와 같은 인터페이스를 분리하여 개선해볼 수 있다.

<img width="447" alt="CleanShot 2023-03-18 at 17 45 34@2x" src="https://user-images.githubusercontent.com/37217320/226095298-5d929689-8856-4b91-bc46-51f7dbe7da45.png">

ISP는 언어 타입에 의존한다고도 볼 수 있다.

- 정적 타입언어는 include로 인해 의존성이 발생하며 이로 인해 재 컴파일 혹은 재배포가 필요할 수도 있다.
- 동적 타입언어는 소스코드 내 선언문이 없으며, 런타임에 추론이 발생하므로 정적타입 언어보다 조금 더 유연하며 결합도가 낮은 시스템을 만들 수 있다.



## 결론

불필요한 짐을 실은 무언가에 의존하면 에상치도 못한 문제에 빠질 수 있다. 이 아이디어는 이후 "컴포넌트 응집도"에서 공통 재사용 원칙을 논할때 다시 다룬다고 한다.

# 11장 DIP: 의존성 역전 원칙

**고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안된다. 세부사항이 정책에 의존해야한다.** 즉 자바와 같은 정적타입 언어에서는 import 구문은 오직 인터페이스나 추상 클래스에만 의존해야하며, 구체 클래스에는 의존해서는 안된다.



다만 규칙으로 보기에는 비현실적이다. `java.lang.String`을 예시로 들 수 있는데, 이에 대한 소스코드 의존성은 벗어날 수 없다. 그러나 거의 변경되지 않으며 매우 안정적이다. 이러한 이유로 **DIP를 논할때는 운영체제나 플랫폼과 같이 안정성이 보장된 환경에 대해서는 무시하는 편이다.**

**즉 변동가능성이 큰 구체적인 요소에 의존하지 않도록 피해야하며 이를 DIP를 통해 피할 수 있다.**

## 안정화된 추상화

인터페이스는 구현체보다 변동성이 낮다. 인터페이스를 변경하지 않고 기능을 추가할 수 있는 방법을 찾기위해 노력하며, 이는 소프트 웨어 설계의 기본이다. 또한 아래와 같은 규칙으로 요약해볼 수도 있다.

- 변동성이 큰 구체클래스를 참조하지 말라
- 변동성이 큰 구체클래스로부터 파생(상속)하지 말라
- 구체 함수를 오버라이드 하지 말라
- 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라



## 팩토리

추상 팩토리는 객체를 생성할때 발생하는 소스코드 의존성을 주로 처리하고자 사용한다.

![CleanShot 2023-03-18 at 17 46 02@2x](https://user-images.githubusercontent.com/37217320/226095332-30abdd67-ab0a-48ff-a8b8-1eedfd7c690e.png)

위 표를 보면 Interface와 구현체 사이에 아키텍처 경계가 존재한다. 아키텍처 경계는 추상적인 것들과 구체적인 것들을 분리하고, 소스 코드 의존성은 모두 한방향 즉 추상적인 쪽으로 향한다.



## 구체 컴포넌트

다만 ServiceImpl은 ConcreateImpl 에 구체적인 의존성이 존재하며, 이는 DIP에 위배된다. 이는 일반적인 일이며 모든 DIP 위배를 모두 없앨 수는 없다. 하지만 적은수의 구체 컴포넌트 내부로 모을 수 있고 이를 통해 나머지 부분과는 분리할 수 있다.



## 결론

DIP는 고수준의 아키텍쳐를 다루다보면 계속해서 등장하는 내용이며, 아키텍쳐 경계가 될 때 곡선이 기반이 될 것이다. 그리고 의존성은 이 곡선을 경계로 더 추상적인 엔티티가 있는 쪽으로만 향하게 되며 추후 이 규칙을 의존성 규칙(Dependency Rule) 이라고 부른다고 한다.
